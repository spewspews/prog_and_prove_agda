\documentclass{article}

\usepackage[paperwidth=5.5in,paperheight=8.5in,margin=0.5in,footskip=.25in]{geometry}
\usepackage{fontspec}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{unicode-math}
\usepackage{fancyvrb}
\usepackage{syntax}
\usepackage{tikz}

\DefineVerbatimEnvironment{code}{Verbatim}{baselinestretch=.8, samepage=true}

\setmainfont{Garamond Premier Pro}[Contextuals=AlternateOff]
\setmathfont{Libertinus Math}[Scale=MatchUppercase]
\setmonofont{Monaspace Argon}[Scale=0.7]

\setlength{\parindent}{1em}
\setlist{noitemsep}

\newcommand{\ttx}{\texttt}

\begin{document}
\noindent
I'm going to learn some agda!

\begin{code}
data Greeting : Set where
    hello : Greeting

greet : Greeting
greet = hello
\end{code}

\noindent
Defining the natural numbers:

\begin{code}
data Nat : Set where
    zero : Nat
    suc : Nat → Nat

{-# BUILTIN NATURAL Nat #-}

_+_ : Nat → Nat → Nat
zero + y = y
suc x + y = suc (x + y)
\end{code}

\noindent
\textsc{Exercise 1.1} Define the function \ttx{halve : Nat → Nat} that computes the result of dividing the given number by 2 (rounded down). Test your definition by evaluating it for several concrete inputs.

\begin{code}
halve : Nat → Nat
halve 0 = 0
halve 1 = 0
halve (suc (suc n)) = halve n + 1
\end{code}

\noindent
\textsc{Exercise 1.2} Define the function \ttx{_*_ : Nat → Nat → Nat} for multiplication of two natural numbers.

\begin{code}
_*_ : Nat → Nat → Nat
0 * y = 0
suc x * y = y + (x * y)
\end{code}

\noindent
\textsc{Exercise 1.3} Define the type Bool with constructors true and false, and define the functions for negation \verb$not : Bool → Bool$, conjunction \verb$_&&_ : Bool → Bool → Bool$, and disjunction \verb$_||_ : Bool → Bool → Bool$ by pattern matching.

\begin{code}
data Bool : Set where
    true : Bool
    false : Bool

not : Bool → Bool
not true = false
not false = true
\end{code}

\begin{code}
id : {A : Set} → A → A
id x = x

data List (A : Set) : Set where
    [] : List A
    _::_ : A → List A → List A

infixr 5 _::_

data _×_ (A B : Set) : Set where
    _,_ : A → B → A × B

fst : {A B : Set} → A × B → A
fst (x , _) = x

snd : {A B : Set} → A × B → B
snd (_ , y) = y
\end{code}

\textsc{Exercise 1.4}
\begin{code}
length : {A : Set} → List A → Nat
length [] = 0
length (x :: xs) = suc (length xs)

_++_ : {A : Set} → List A → List A → List A
[] ++ ys = ys
(x :: xs) ++ ys = x :: (xs ++ ys)

map : {A B : Set} → (A → B) → List A → List B
map f [] = []
map f (x :: xs) = f x :: map f xs
\end{code}

\textsc{Exercise 1.5}
\begin{code}
data Maybe (A : Set) : Set where
    nothing : Maybe A
    just : A -> Maybe A

lookup : {A : Set} → List A → Nat → Maybe A
lookup [] _ = nothing
lookup (x :: xs) zero = just x
lookup (x :: xs) (suc i) = lookup xs i
\end{code}

\end{document}
